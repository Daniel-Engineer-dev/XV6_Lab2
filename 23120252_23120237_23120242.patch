diff --git a/23120252_23120237_23120242.patch b/23120252_23120237_23120242.patch
index 5f795f4..e69de29 100644
--- a/23120252_23120237_23120242.patch
+++ b/23120252_23120237_23120242.patch
@@ -1,2194 +0,0 @@
-diff --git a/kernel/defs.h b/kernel/defs.h
-index d133cd3..39905fe 100644
---- a/kernel/defs.h
-+++ b/kernel/defs.h
-@@ -14,226 +14,226 @@ struct stat;
- struct superblock;
- 
- // bio.c
--void            binit(void);
--struct buf*     bread(uint, uint);
--void            brelse(struct buf*);
--void            bwrite(struct buf*);
--void            bpin(struct buf*);
--void            bunpin(struct buf*);
-+void binit(void);
-+struct buf *bread(uint, uint);
-+void brelse(struct buf *);
-+void bwrite(struct buf *);
-+void bpin(struct buf *);
-+void bunpin(struct buf *);
- 
- // console.c
--void            consoleinit(void);
--void            consoleintr(int);
--void            consputc(int);
-+void consoleinit(void);
-+void consoleintr(int);
-+void consputc(int);
- 
- // exec.c
--int             exec(char*, char**);
-+int exec(char *, char **);
- 
- // file.c
--struct file*    filealloc(void);
--void            fileclose(struct file*);
--struct file*    filedup(struct file*);
--void            fileinit(void);
--int             fileread(struct file*, uint64, int n);
--int             filestat(struct file*, uint64 addr);
--int             filewrite(struct file*, uint64, int n);
-+struct file *filealloc(void);
-+void fileclose(struct file *);
-+struct file *filedup(struct file *);
-+void fileinit(void);
-+int fileread(struct file *, uint64, int n);
-+int filestat(struct file *, uint64 addr);
-+int filewrite(struct file *, uint64, int n);
- 
- // fs.c
--void            fsinit(int);
--int             dirlink(struct inode*, char*, uint);
--struct inode*   dirlookup(struct inode*, char*, uint*);
--struct inode*   ialloc(uint, short);
--struct inode*   idup(struct inode*);
--void            iinit();
--void            ilock(struct inode*);
--void            iput(struct inode*);
--void            iunlock(struct inode*);
--void            iunlockput(struct inode*);
--void            iupdate(struct inode*);
--int             namecmp(const char*, const char*);
--struct inode*   namei(char*);
--struct inode*   nameiparent(char*, char*);
--int             readi(struct inode*, int, uint64, uint, uint);
--void            stati(struct inode*, struct stat*);
--int             writei(struct inode*, int, uint64, uint, uint);
--void            itrunc(struct inode*);
-+void fsinit(int);
-+int dirlink(struct inode *, char *, uint);
-+struct inode *dirlookup(struct inode *, char *, uint *);
-+struct inode *ialloc(uint, short);
-+struct inode *idup(struct inode *);
-+void iinit();
-+void ilock(struct inode *);
-+void iput(struct inode *);
-+void iunlock(struct inode *);
-+void iunlockput(struct inode *);
-+void iupdate(struct inode *);
-+int namecmp(const char *, const char *);
-+struct inode *namei(char *);
-+struct inode *nameiparent(char *, char *);
-+int readi(struct inode *, int, uint64, uint, uint);
-+void stati(struct inode *, struct stat *);
-+int writei(struct inode *, int, uint64, uint, uint);
-+void itrunc(struct inode *);
- 
- // ramdisk.c
--void            ramdiskinit(void);
--void            ramdiskintr(void);
--void            ramdiskrw(struct buf*);
-+void ramdiskinit(void);
-+void ramdiskintr(void);
-+void ramdiskrw(struct buf *);
- 
- // kalloc.c
--void*           kalloc(void);
--void            kfree(void *);
--void            kinit(void);
-+void *kalloc(void);
-+void kfree(void *);
-+void kinit(void);
- 
- // log.c
--void            initlog(int, struct superblock*);
--void            log_write(struct buf*);
--void            begin_op(void);
--void            end_op(void);
-+void initlog(int, struct superblock *);
-+void log_write(struct buf *);
-+void begin_op(void);
-+void end_op(void);
- 
- // pipe.c
--int             pipealloc(struct file**, struct file**);
--void            pipeclose(struct pipe*, int);
--int             piperead(struct pipe*, uint64, int);
--int             pipewrite(struct pipe*, uint64, int);
-+int pipealloc(struct file **, struct file **);
-+void pipeclose(struct pipe *, int);
-+int piperead(struct pipe *, uint64, int);
-+int pipewrite(struct pipe *, uint64, int);
- 
- // printf.c
--int            printf(char*, ...) __attribute__ ((format (printf, 1, 2)));
--void            panic(char*) __attribute__((noreturn));
--void            printfinit(void);
-+int printf(char *, ...) __attribute__((format(printf, 1, 2)));
-+void panic(char *) __attribute__((noreturn));
-+void printfinit(void);
- 
- // proc.c
--int             cpuid(void);
--void            exit(int);
--int             fork(void);
--int             growproc(int);
--void            proc_mapstacks(pagetable_t);
--pagetable_t     proc_pagetable(struct proc *);
--void            proc_freepagetable(pagetable_t, uint64);
--int             kill(int);
--int             killed(struct proc*);
--void            setkilled(struct proc*);
--struct cpu*     mycpu(void);
--struct cpu*     getmycpu(void);
--struct proc*    myproc();
--void            procinit(void);
--void            scheduler(void) __attribute__((noreturn));
--void            sched(void);
--void            sleep(void*, struct spinlock*);
--void            userinit(void);
--int             wait(uint64);
--void            wakeup(void*);
--void            yield(void);
--int             either_copyout(int user_dst, uint64 dst, void *src, uint64 len);
--int             either_copyin(void *dst, int user_src, uint64 src, uint64 len);
--void            procdump(void);
-+int cpuid(void);
-+void exit(int);
-+int fork(void);
-+int growproc(int);
-+void proc_mapstacks(pagetable_t);
-+pagetable_t proc_pagetable(struct proc *);
-+void proc_freepagetable(pagetable_t, uint64);
-+int kill(int);
-+int killed(struct proc *);
-+void setkilled(struct proc *);
-+struct cpu *mycpu(void);
-+struct cpu *getmycpu(void);
-+struct proc *myproc();
-+void procinit(void);
-+void scheduler(void) __attribute__((noreturn));
-+void sched(void);
-+void sleep(void *, struct spinlock *);
-+void userinit(void);
-+int wait(uint64);
-+void wakeup(void *);
-+void yield(void);
-+int either_copyout(int user_dst, uint64 dst, void *src, uint64 len);
-+int either_copyin(void *dst, int user_src, uint64 src, uint64 len);
-+void procdump(void);
- 
- // swtch.S
--void            swtch(struct context*, struct context*);
-+void swtch(struct context *, struct context *);
- 
- // spinlock.c
--void            acquire(struct spinlock*);
--int             holding(struct spinlock*);
--void            initlock(struct spinlock*, char*);
--void            release(struct spinlock*);
--void            push_off(void);
--void            pop_off(void);
--int             atomic_read4(int *addr);
-+void acquire(struct spinlock *);
-+int holding(struct spinlock *);
-+void initlock(struct spinlock *, char *);
-+void release(struct spinlock *);
-+void push_off(void);
-+void pop_off(void);
-+int atomic_read4(int *addr);
- #ifdef LAB_LOCK
--void            freelock(struct spinlock*);
-+void freelock(struct spinlock *);
- #endif
- 
- // sleeplock.c
--void            acquiresleep(struct sleeplock*);
--void            releasesleep(struct sleeplock*);
--int             holdingsleep(struct sleeplock*);
--void            initsleeplock(struct sleeplock*, char*);
-+void acquiresleep(struct sleeplock *);
-+void releasesleep(struct sleeplock *);
-+int holdingsleep(struct sleeplock *);
-+void initsleeplock(struct sleeplock *, char *);
- 
- // string.c
--int             memcmp(const void*, const void*, uint);
--void*           memmove(void*, const void*, uint);
--void*           memset(void*, int, uint);
--char*           safestrcpy(char*, const char*, int);
--int             strlen(const char*);
--int             strncmp(const char*, const char*, uint);
--char*           strncpy(char*, const char*, int);
-+int memcmp(const void *, const void *, uint);
-+void *memmove(void *, const void *, uint);
-+void *memset(void *, int, uint);
-+char *safestrcpy(char *, const char *, int);
-+int strlen(const char *);
-+int strncmp(const char *, const char *, uint);
-+char *strncpy(char *, const char *, int);
- 
- // syscall.c
--void            argint(int, int*);
--int             argstr(int, char*, int);
--void            argaddr(int, uint64 *);
--int             fetchstr(uint64, char*, int);
--int             fetchaddr(uint64, uint64*);
--void            syscall();
-+void argint(int, int *);
-+int argstr(int, char *, int);
-+void argaddr(int, uint64 *);
-+int fetchstr(uint64, char *, int);
-+int fetchaddr(uint64, uint64 *);
-+void syscall();
- 
- // trap.c
--extern uint     ticks;
--void            trapinit(void);
--void            trapinithart(void);
-+extern uint ticks;
-+void trapinit(void);
-+void trapinithart(void);
- extern struct spinlock tickslock;
--void            usertrapret(void);
-+void usertrapret(void);
- 
- // uart.c
--void            uartinit(void);
--void            uartintr(void);
--void            uartputc(int);
--void            uartputc_sync(int);
--int             uartgetc(void);
-+void uartinit(void);
-+void uartintr(void);
-+void uartputc(int);
-+void uartputc_sync(int);
-+int uartgetc(void);
- 
- // vm.c
--void            kvminit(void);
--void            kvminithart(void);
--void            kvmmap(pagetable_t, uint64, uint64, uint64, int);
--int             mappages(pagetable_t, uint64, uint64, uint64, int);
--pagetable_t     uvmcreate(void);
--void            uvmfirst(pagetable_t, uchar *, uint);
--uint64          uvmalloc(pagetable_t, uint64, uint64, int);
--uint64          uvmdealloc(pagetable_t, uint64, uint64);
--int             uvmcopy(pagetable_t, pagetable_t, uint64);
--void            uvmfree(pagetable_t, uint64);
--void            uvmunmap(pagetable_t, uint64, uint64, int);
--void            uvmclear(pagetable_t, uint64);
--pte_t *         walk(pagetable_t, uint64, int);
--uint64          walkaddr(pagetable_t, uint64);
--int             copyout(pagetable_t, uint64, char *, uint64);
--int             copyin(pagetable_t, char *, uint64, uint64);
--int             copyinstr(pagetable_t, char *, uint64, uint64);
-+void kvminit(void);
-+void kvminithart(void);
-+void kvmmap(pagetable_t, uint64, uint64, uint64, int);
-+int mappages(pagetable_t, uint64, uint64, uint64, int);
-+pagetable_t uvmcreate(void);
-+void uvmfirst(pagetable_t, uchar *, uint);
-+uint64 uvmalloc(pagetable_t, uint64, uint64, int);
-+uint64 uvmdealloc(pagetable_t, uint64, uint64);
-+int uvmcopy(pagetable_t, pagetable_t, uint64);
-+void uvmfree(pagetable_t, uint64);
-+void uvmunmap(pagetable_t, uint64, uint64, int);
-+void uvmclear(pagetable_t, uint64);
-+pte_t *walk(pagetable_t, uint64, int);
-+uint64 walkaddr(pagetable_t, uint64);
-+int copyout(pagetable_t, uint64, char *, uint64);
-+int copyin(pagetable_t, char *, uint64, uint64);
-+int copyinstr(pagetable_t, char *, uint64, uint64);
- #if defined(LAB_PGTBL) || defined(SOL_MMAP)
--void            vmprint(pagetable_t);
-+void vmprint(pagetable_t);
- #endif
- #ifdef LAB_PGTBL
--pte_t*          pgpte(pagetable_t, uint64);
-+pte_t *pgpte(pagetable_t, uint64);
- #endif
- 
- // plic.c
--void            plicinit(void);
--void            plicinithart(void);
--int             plic_claim(void);
--void            plic_complete(int);
-+void plicinit(void);
-+void plicinithart(void);
-+int plic_claim(void);
-+void plic_complete(int);
- 
- // virtio_disk.c
--void            virtio_disk_init(void);
--void            virtio_disk_rw(struct buf *, int);
--void            virtio_disk_intr(void);
-+void virtio_disk_init(void);
-+void virtio_disk_rw(struct buf *, int);
-+void virtio_disk_intr(void);
- 
- // number of elements in fixed-size array
--#define NELEM(x) (sizeof(x)/sizeof((x)[0]))
--
--
-+#define NELEM(x) (sizeof(x) / sizeof((x)[0]))
- 
- #ifdef LAB_PGTBL
- // vmcopyin.c
--int             copyin_new(pagetable_t, char *, uint64, uint64);
--int             copyinstr_new(pagetable_t, char *, uint64, uint64);
-+int copyin_new(pagetable_t, char *, uint64, uint64);
-+int copyinstr_new(pagetable_t, char *, uint64, uint64);
- #endif
- 
- #ifdef LAB_LOCK
- // stats.c
--void            statsinit(void);
--void            statsinc(void);
-+void statsinit(void);
-+void statsinc(void);
- 
- // sprintf.c
--int             snprintf(char*, unsigned long, const char*, ...);
-+int snprintf(char *, unsigned long, const char *, ...);
- #endif
- 
- #ifdef KCSAN
--void            kcsaninit();
-+void kcsaninit();
- #endif
- 
- #ifdef LAB_NET
- // pci.c
--void            pci_init();
-+void pci_init();
- 
- // e1000.c
--void            e1000_init(uint32 *);
--void            e1000_intr(void);
--int             e1000_transmit(char *, int);
-+void e1000_init(uint32 *);
-+void e1000_intr(void);
-+int e1000_transmit(char *, int);
- 
- // net.c
--void            netinit(void);
--void            net_rx(char *buf, int len);
-+void netinit(void);
-+void net_rx(char *buf, int len);
- 
- #endif
-+
-+void vmprint(pagetable_t pagetable);
-diff --git a/kernel/exec.c b/kernel/exec.c
-index 6d7c452..2a54e19 100644
---- a/kernel/exec.c
-+++ b/kernel/exec.c
-@@ -11,16 +11,15 @@ static int loadseg(pde_t *, uint64, struct inode *, uint, uint);
- 
- int flags2perm(int flags)
- {
--    int perm = 0;
--    if(flags & 0x1)
--      perm = PTE_X;
--    if(flags & 0x2)
--      perm |= PTE_W;
--    return perm;
-+  int perm = 0;
-+  if (flags & 0x1)
-+    perm = PTE_X;
-+  if (flags & 0x2)
-+    perm |= PTE_W;
-+  return perm;
- }
- 
--int
--exec(char *path, char **argv)
-+int exec(char *path, char **argv)
- {
-   char *s, *last;
-   int i, off;
-@@ -33,39 +32,41 @@ exec(char *path, char **argv)
- 
-   begin_op();
- 
--  if((ip = namei(path)) == 0){
-+  if ((ip = namei(path)) == 0)
-+  {
-     end_op();
-     return -1;
-   }
-   ilock(ip);
- 
-   // Check ELF header
--  if(readi(ip, 0, (uint64)&elf, 0, sizeof(elf)) != sizeof(elf))
-+  if (readi(ip, 0, (uint64)&elf, 0, sizeof(elf)) != sizeof(elf))
-     goto bad;
- 
--  if(elf.magic != ELF_MAGIC)
-+  if (elf.magic != ELF_MAGIC)
-     goto bad;
- 
--  if((pagetable = proc_pagetable(p)) == 0)
-+  if ((pagetable = proc_pagetable(p)) == 0)
-     goto bad;
- 
-   // Load program into memory.
--  for(i=0, off=elf.phoff; i<elf.phnum; i++, off+=sizeof(ph)){
--    if(readi(ip, 0, (uint64)&ph, off, sizeof(ph)) != sizeof(ph))
-+  for (i = 0, off = elf.phoff; i < elf.phnum; i++, off += sizeof(ph))
-+  {
-+    if (readi(ip, 0, (uint64)&ph, off, sizeof(ph)) != sizeof(ph))
-       goto bad;
--    if(ph.type != ELF_PROG_LOAD)
-+    if (ph.type != ELF_PROG_LOAD)
-       continue;
--    if(ph.memsz < ph.filesz)
-+    if (ph.memsz < ph.filesz)
-       goto bad;
--    if(ph.vaddr + ph.memsz < ph.vaddr)
-+    if (ph.vaddr + ph.memsz < ph.vaddr)
-       goto bad;
--    if(ph.vaddr % PGSIZE != 0)
-+    if (ph.vaddr % PGSIZE != 0)
-       goto bad;
-     uint64 sz1;
--    if((sz1 = uvmalloc(pagetable, sz, ph.vaddr + ph.memsz, flags2perm(ph.flags))) == 0)
-+    if ((sz1 = uvmalloc(pagetable, sz, ph.vaddr + ph.memsz, flags2perm(ph.flags))) == 0)
-       goto bad;
-     sz = sz1;
--    if(loadseg(pagetable, ph.vaddr, ip, ph.off, ph.filesz) < 0)
-+    if (loadseg(pagetable, ph.vaddr, ip, ph.off, ph.filesz) < 0)
-       goto bad;
-   }
-   iunlockput(ip);
-@@ -80,33 +81,34 @@ exec(char *path, char **argv)
-   // Use the rest as the user stack.
-   sz = PGROUNDUP(sz);
-   uint64 sz1;
--  if((sz1 = uvmalloc(pagetable, sz, sz + (USERSTACK+1)*PGSIZE, PTE_W)) == 0)
-+  if ((sz1 = uvmalloc(pagetable, sz, sz + (USERSTACK + 1) * PGSIZE, PTE_W)) == 0)
-     goto bad;
-   sz = sz1;
--  uvmclear(pagetable, sz-(USERSTACK+1)*PGSIZE);
-+  uvmclear(pagetable, sz - (USERSTACK + 1) * PGSIZE);
-   sp = sz;
--  stackbase = sp - USERSTACK*PGSIZE;
-+  stackbase = sp - USERSTACK * PGSIZE;
- 
-   // Push argument strings, prepare rest of stack in ustack.
--  for(argc = 0; argv[argc]; argc++) {
--    if(argc >= MAXARG)
-+  for (argc = 0; argv[argc]; argc++)
-+  {
-+    if (argc >= MAXARG)
-       goto bad;
-     sp -= strlen(argv[argc]) + 1;
-     sp -= sp % 16; // riscv sp must be 16-byte aligned
--    if(sp < stackbase)
-+    if (sp < stackbase)
-       goto bad;
--    if(copyout(pagetable, sp, argv[argc], strlen(argv[argc]) + 1) < 0)
-+    if (copyout(pagetable, sp, argv[argc], strlen(argv[argc]) + 1) < 0)
-       goto bad;
-     ustack[argc] = sp;
-   }
-   ustack[argc] = 0;
- 
-   // push the array of argv[] pointers.
--  sp -= (argc+1) * sizeof(uint64);
-+  sp -= (argc + 1) * sizeof(uint64);
-   sp -= sp % 16;
--  if(sp < stackbase)
-+  if (sp < stackbase)
-     goto bad;
--  if(copyout(pagetable, sp, (char *)ustack, (argc+1)*sizeof(uint64)) < 0)
-+  if (copyout(pagetable, sp, (char *)ustack, (argc + 1) * sizeof(uint64)) < 0)
-     goto bad;
- 
-   // arguments to user main(argc, argv)
-@@ -115,25 +117,28 @@ exec(char *path, char **argv)
-   p->trapframe->a1 = sp;
- 
-   // Save program name for debugging.
--  for(last=s=path; *s; s++)
--    if(*s == '/')
--      last = s+1;
-+  for (last = s = path; *s; s++)
-+    if (*s == '/')
-+      last = s + 1;
-   safestrcpy(p->name, last, sizeof(p->name));
--    
-+
-   // Commit to the user image.
-   oldpagetable = p->pagetable;
-   p->pagetable = pagetable;
-   p->sz = sz;
--  p->trapframe->epc = elf.entry;  // initial program counter = main
--  p->trapframe->sp = sp; // initial stack pointer
-+  p->trapframe->epc = elf.entry; // initial program counter = main
-+  p->trapframe->sp = sp;         // initial stack pointer
-   proc_freepagetable(oldpagetable, oldsz);
- 
-+  vmprint(p->pagetable);
-+
-   return argc; // this ends up in a0, the first argument to main(argc, argv)
- 
-- bad:
--  if(pagetable)
-+bad:
-+  if (pagetable)
-     proc_freepagetable(pagetable, sz);
--  if(ip){
-+  if (ip)
-+  {
-     iunlockput(ip);
-     end_op();
-   }
-@@ -150,17 +155,18 @@ loadseg(pagetable_t pagetable, uint64 va, struct inode *ip, uint offset, uint sz
-   uint i, n;
-   uint64 pa;
- 
--  for(i = 0; i < sz; i += PGSIZE){
-+  for (i = 0; i < sz; i += PGSIZE)
-+  {
-     pa = walkaddr(pagetable, va + i);
--    if(pa == 0)
-+    if (pa == 0)
-       panic("loadseg: address should exist");
--    if(sz - i < PGSIZE)
-+    if (sz - i < PGSIZE)
-       n = sz - i;
-     else
-       n = PGSIZE;
--    if(readi(ip, 0, (uint64)pa, offset+i, n) != n)
-+    if (readi(ip, 0, (uint64)pa, offset + i, n) != n)
-       return -1;
-   }
--  
-+
-   return 0;
- }
-diff --git a/kernel/riscv.h b/kernel/riscv.h
-index 6cfff1e..476d969 100644
---- a/kernel/riscv.h
-+++ b/kernel/riscv.h
-@@ -5,7 +5,7 @@ static inline uint64
- r_mhartid()
- {
-   uint64 x;
--  asm volatile("csrr %0, mhartid" : "=r" (x) );
-+  asm volatile("csrr %0, mhartid" : "=r"(x));
-   return x;
- }
- 
-@@ -15,29 +15,29 @@ r_mhartid()
- #define MSTATUS_MPP_M (3L << 11)
- #define MSTATUS_MPP_S (1L << 11)
- #define MSTATUS_MPP_U (0L << 11)
--#define MSTATUS_MIE (1L << 3)    // machine-mode interrupt enable.
-+#define MSTATUS_MIE (1L << 3) // machine-mode interrupt enable.
- 
- static inline uint64
- r_mstatus()
- {
-   uint64 x;
--  asm volatile("csrr %0, mstatus" : "=r" (x) );
-+  asm volatile("csrr %0, mstatus" : "=r"(x));
-   return x;
- }
- 
--static inline void 
-+static inline void
- w_mstatus(uint64 x)
- {
--  asm volatile("csrw mstatus, %0" : : "r" (x));
-+  asm volatile("csrw mstatus, %0" : : "r"(x));
- }
- 
- // machine exception program counter, holds the
- // instruction address to which a return from
- // exception will go.
--static inline void 
-+static inline void
- w_mepc(uint64 x)
- {
--  asm volatile("csrw mepc, %0" : : "r" (x));
-+  asm volatile("csrw mepc, %0" : : "r"(x));
- }
- 
- // Supervisor Status Register, sstatus
-@@ -52,14 +52,14 @@ static inline uint64
- r_sstatus()
- {
-   uint64 x;
--  asm volatile("csrr %0, sstatus" : "=r" (x) );
-+  asm volatile("csrr %0, sstatus" : "=r"(x));
-   return x;
- }
- 
--static inline void 
-+static inline void
- w_sstatus(uint64 x)
- {
--  asm volatile("csrw sstatus, %0" : : "r" (x));
-+  asm volatile("csrw sstatus, %0" : : "r"(x));
- }
- 
- // Supervisor Interrupt Pending
-@@ -67,14 +67,14 @@ static inline uint64
- r_sip()
- {
-   uint64 x;
--  asm volatile("csrr %0, sip" : "=r" (x) );
-+  asm volatile("csrr %0, sip" : "=r"(x));
-   return x;
- }
- 
--static inline void 
-+static inline void
- w_sip(uint64 x)
- {
--  asm volatile("csrw sip, %0" : : "r" (x));
-+  asm volatile("csrw sip, %0" : : "r"(x));
- }
- 
- // Supervisor Interrupt Enable
-@@ -85,46 +85,46 @@ static inline uint64
- r_sie()
- {
-   uint64 x;
--  asm volatile("csrr %0, sie" : "=r" (x) );
-+  asm volatile("csrr %0, sie" : "=r"(x));
-   return x;
- }
- 
--static inline void 
-+static inline void
- w_sie(uint64 x)
- {
--  asm volatile("csrw sie, %0" : : "r" (x));
-+  asm volatile("csrw sie, %0" : : "r"(x));
- }
- 
- // Machine-mode Interrupt Enable
--#define MIE_STIE (1L << 5)  // supervisor timer
-+#define MIE_STIE (1L << 5) // supervisor timer
- static inline uint64
- r_mie()
- {
-   uint64 x;
--  asm volatile("csrr %0, mie" : "=r" (x) );
-+  asm volatile("csrr %0, mie" : "=r"(x));
-   return x;
- }
- 
--static inline void 
-+static inline void
- w_mie(uint64 x)
- {
--  asm volatile("csrw mie, %0" : : "r" (x));
-+  asm volatile("csrw mie, %0" : : "r"(x));
- }
- 
- // supervisor exception program counter, holds the
- // instruction address to which a return from
- // exception will go.
--static inline void 
-+static inline void
- w_sepc(uint64 x)
- {
--  asm volatile("csrw sepc, %0" : : "r" (x));
-+  asm volatile("csrw sepc, %0" : : "r"(x));
- }
- 
- static inline uint64
- r_sepc()
- {
-   uint64 x;
--  asm volatile("csrr %0, sepc" : "=r" (x) );
-+  asm volatile("csrr %0, sepc" : "=r"(x));
-   return x;
- }
- 
-@@ -133,14 +133,14 @@ static inline uint64
- r_medeleg()
- {
-   uint64 x;
--  asm volatile("csrr %0, medeleg" : "=r" (x) );
-+  asm volatile("csrr %0, medeleg" : "=r"(x));
-   return x;
- }
- 
--static inline void 
-+static inline void
- w_medeleg(uint64 x)
- {
--  asm volatile("csrw medeleg, %0" : : "r" (x));
-+  asm volatile("csrw medeleg, %0" : : "r"(x));
- }
- 
- // Machine Interrupt Delegation
-@@ -148,29 +148,29 @@ static inline uint64
- r_mideleg()
- {
-   uint64 x;
--  asm volatile("csrr %0, mideleg" : "=r" (x) );
-+  asm volatile("csrr %0, mideleg" : "=r"(x));
-   return x;
- }
- 
--static inline void 
-+static inline void
- w_mideleg(uint64 x)
- {
--  asm volatile("csrw mideleg, %0" : : "r" (x));
-+  asm volatile("csrw mideleg, %0" : : "r"(x));
- }
- 
- // Supervisor Trap-Vector Base Address
- // low two bits are mode.
--static inline void 
-+static inline void
- w_stvec(uint64 x)
- {
--  asm volatile("csrw stvec, %0" : : "r" (x));
-+  asm volatile("csrw stvec, %0" : : "r"(x));
- }
- 
- static inline uint64
- r_stvec()
- {
-   uint64 x;
--  asm volatile("csrr %0, stvec" : "=r" (x) );
-+  asm volatile("csrr %0, stvec" : "=r"(x));
-   return x;
- }
- 
-@@ -180,15 +180,15 @@ r_stimecmp()
- {
-   uint64 x;
-   // asm volatile("csrr %0, stimecmp" : "=r" (x) );
--  asm volatile("csrr %0, 0x14d" : "=r" (x) );
-+  asm volatile("csrr %0, 0x14d" : "=r"(x));
-   return x;
- }
- 
--static inline void 
-+static inline void
- w_stimecmp(uint64 x)
- {
-   // asm volatile("csrw stimecmp, %0" : : "r" (x));
--  asm volatile("csrw 0x14d, %0" : : "r" (x));
-+  asm volatile("csrw 0x14d, %0" : : "r"(x));
- }
- 
- // Machine Environment Configuration Register
-@@ -197,28 +197,28 @@ r_menvcfg()
- {
-   uint64 x;
-   // asm volatile("csrr %0, menvcfg" : "=r" (x) );
--  asm volatile("csrr %0, 0x30a" : "=r" (x) );
-+  asm volatile("csrr %0, 0x30a" : "=r"(x));
-   return x;
- }
- 
--static inline void 
-+static inline void
- w_menvcfg(uint64 x)
- {
--  //asm volatile("csrw menvcfg, %0" : : "r" (x));
--  asm volatile("csrw 0x30a, %0" : : "r" (x));
-+  // asm volatile("csrw menvcfg, %0" : : "r" (x));
-+  asm volatile("csrw 0x30a, %0" : : "r"(x));
- }
- 
- // Physical Memory Protection
- static inline void
- w_pmpcfg0(uint64 x)
- {
--  asm volatile("csrw pmpcfg0, %0" : : "r" (x));
-+  asm volatile("csrw pmpcfg0, %0" : : "r"(x));
- }
- 
- static inline void
- w_pmpaddr0(uint64 x)
- {
--  asm volatile("csrw pmpaddr0, %0" : : "r" (x));
-+  asm volatile("csrw pmpaddr0, %0" : : "r"(x));
- }
- 
- // use riscv's sv39 page table scheme.
-@@ -228,17 +228,17 @@ w_pmpaddr0(uint64 x)
- 
- // supervisor address translation and protection;
- // holds the address of the page table.
--static inline void 
-+static inline void
- w_satp(uint64 x)
- {
--  asm volatile("csrw satp, %0" : : "r" (x));
-+  asm volatile("csrw satp, %0" : : "r"(x));
- }
- 
- static inline uint64
- r_satp()
- {
-   uint64 x;
--  asm volatile("csrr %0, satp" : "=r" (x) );
-+  asm volatile("csrr %0, satp" : "=r"(x));
-   return x;
- }
- 
-@@ -247,7 +247,7 @@ static inline uint64
- r_scause()
- {
-   uint64 x;
--  asm volatile("csrr %0, scause" : "=r" (x) );
-+  asm volatile("csrr %0, scause" : "=r"(x));
-   return x;
- }
- 
-@@ -256,22 +256,22 @@ static inline uint64
- r_stval()
- {
-   uint64 x;
--  asm volatile("csrr %0, stval" : "=r" (x) );
-+  asm volatile("csrr %0, stval" : "=r"(x));
-   return x;
- }
- 
- // Machine-mode Counter-Enable
--static inline void 
-+static inline void
- w_mcounteren(uint64 x)
- {
--  asm volatile("csrw mcounteren, %0" : : "r" (x));
-+  asm volatile("csrw mcounteren, %0" : : "r"(x));
- }
- 
- static inline uint64
- r_mcounteren()
- {
-   uint64 x;
--  asm volatile("csrr %0, mcounteren" : "=r" (x) );
-+  asm volatile("csrr %0, mcounteren" : "=r"(x));
-   return x;
- }
- 
-@@ -280,7 +280,7 @@ static inline uint64
- r_time()
- {
-   uint64 x;
--  asm volatile("csrr %0, time" : "=r" (x) );
-+  asm volatile("csrr %0, time" : "=r"(x));
-   return x;
- }
- 
-@@ -310,7 +310,7 @@ static inline uint64
- r_sp()
- {
-   uint64 x;
--  asm volatile("mv %0, sp" : "=r" (x) );
-+  asm volatile("mv %0, sp" : "=r"(x));
-   return x;
- }
- 
-@@ -318,7 +318,7 @@ static inline uint64
- r_fp()
- {
-   uint64 x;
--  asm volatile("mv %0, s0" : "=r" (x) );
-+  asm volatile("mv %0, s0" : "=r"(x));
-   return x;
- }
- 
-@@ -328,21 +328,21 @@ static inline uint64
- r_tp()
- {
-   uint64 x;
--  asm volatile("mv %0, tp" : "=r" (x) );
-+  asm volatile("mv %0, tp" : "=r"(x));
-   return x;
- }
- 
--static inline void 
-+static inline void
- w_tp(uint64 x)
- {
--  asm volatile("mv tp, %0" : : "r" (x));
-+  asm volatile("mv tp, %0" : : "r"(x));
- }
- 
- static inline uint64
- r_ra()
- {
-   uint64 x;
--  asm volatile("mv %0, ra" : "=r" (x) );
-+  asm volatile("mv %0, ra" : "=r"(x));
-   return x;
- }
- 
-@@ -364,19 +364,19 @@ typedef uint64 *pagetable_t; // 512 PTEs
- 
- #ifdef LAB_PGTBL
- #define SUPERPGSIZE (2 * (1 << 20)) // bytes per page
--#define SUPERPGROUNDUP(sz)  (((sz)+SUPERPGSIZE-1) & ~(SUPERPGSIZE-1))
-+#define SUPERPGROUNDUP(sz) (((sz) + SUPERPGSIZE - 1) & ~(SUPERPGSIZE - 1))
- #endif
- 
--#define PGROUNDUP(sz)  (((sz)+PGSIZE-1) & ~(PGSIZE-1))
--#define PGROUNDDOWN(a) (((a)) & ~(PGSIZE-1))
-+#define PGROUNDUP(sz) (((sz) + PGSIZE - 1) & ~(PGSIZE - 1))
-+#define PGROUNDDOWN(a) (((a)) & ~(PGSIZE - 1))
- 
- #define PTE_V (1L << 0) // valid
- #define PTE_R (1L << 1)
- #define PTE_W (1L << 2)
- #define PTE_X (1L << 3)
- #define PTE_U (1L << 4) // user can access
--
--
-+// Định nghĩa thêm để thực hiện pageaccess
-+#define PTE_A (1L << 6)
- 
- #if defined(LAB_MMAP) || defined(LAB_PGTBL)
- #define PTE_LEAF(pte) (((pte) & PTE_R) | ((pte) & PTE_W) | ((pte) & PTE_X))
-@@ -390,9 +390,9 @@ typedef uint64 *pagetable_t; // 512 PTEs
- #define PTE_FLAGS(pte) ((pte) & 0x3FF)
- 
- // extract the three 9-bit page table indices from a virtual address.
--#define PXMASK          0x1FF // 9 bits
--#define PXSHIFT(level)  (PGSHIFT+(9*(level)))
--#define PX(level, va) ((((uint64) (va)) >> PXSHIFT(level)) & PXMASK)
-+#define PXMASK 0x1FF // 9 bits
-+#define PXSHIFT(level) (PGSHIFT + (9 * (level)))
-+#define PX(level, va) ((((uint64)(va)) >> PXSHIFT(level)) & PXMASK)
- 
- // one beyond the highest possible virtual address.
- // MAXVA is actually one bit less than the max allowed by
-diff --git a/kernel/syscall.c b/kernel/syscall.c
-index 4aea542..fa6a2b4 100644
---- a/kernel/syscall.c
-+++ b/kernel/syscall.c
-@@ -8,24 +8,22 @@
- #include "defs.h"
- 
- // Fetch the uint64 at addr from the current process.
--int
--fetchaddr(uint64 addr, uint64 *ip)
-+int fetchaddr(uint64 addr, uint64 *ip)
- {
-   struct proc *p = myproc();
--  if(addr >= p->sz || addr+sizeof(uint64) > p->sz) // both tests needed, in case of overflow
-+  if (addr >= p->sz || addr + sizeof(uint64) > p->sz) // both tests needed, in case of overflow
-     return -1;
--  if(copyin(p->pagetable, (char *)ip, addr, sizeof(*ip)) != 0)
-+  if (copyin(p->pagetable, (char *)ip, addr, sizeof(*ip)) != 0)
-     return -1;
-   return 0;
- }
- 
- // Fetch the nul-terminated string at addr from the current process.
- // Returns length of string, not including nul, or -1 for error.
--int
--fetchstr(uint64 addr, char *buf, int max)
-+int fetchstr(uint64 addr, char *buf, int max)
- {
-   struct proc *p = myproc();
--  if(copyinstr(p->pagetable, buf, addr, max) < 0)
-+  if (copyinstr(p->pagetable, buf, addr, max) < 0)
-     return -1;
-   return strlen(buf);
- }
-@@ -34,7 +32,8 @@ static uint64
- argraw(int n)
- {
-   struct proc *p = myproc();
--  switch (n) {
-+  switch (n)
-+  {
-   case 0:
-     return p->trapframe->a0;
-   case 1:
-@@ -53,8 +52,7 @@ argraw(int n)
- }
- 
- // Fetch the nth 32-bit system call argument.
--void
--argint(int n, int *ip)
-+void argint(int n, int *ip)
- {
-   *ip = argraw(n);
- }
-@@ -62,8 +60,7 @@ argint(int n, int *ip)
- // Retrieve an argument as a pointer.
- // Doesn't check for legality, since
- // copyin/copyout will do that.
--void
--argaddr(int n, uint64 *ip)
-+void argaddr(int n, uint64 *ip)
- {
-   *ip = argraw(n);
- }
-@@ -71,8 +68,7 @@ argaddr(int n, uint64 *ip)
- // Fetch the nth word-sized system call argument as a null-terminated string.
- // Copies into buf, at most max.
- // Returns string length if OK (including nul), -1 if error.
--int
--argstr(int n, char *buf, int max)
-+int argstr(int n, char *buf, int max)
- {
-   uint64 addr;
-   argaddr(n, &addr);
-@@ -112,59 +108,62 @@ extern uint64 sys_recv(void);
- extern uint64 sys_pgpte(void);
- extern uint64 sys_kpgtbl(void);
- #endif
-+//
-+extern uint64 sys_pgaccess(void);
- 
- // An array mapping syscall numbers from syscall.h
- // to the function that handles the system call.
- static uint64 (*syscalls[])(void) = {
--[SYS_fork]    sys_fork,
--[SYS_exit]    sys_exit,
--[SYS_wait]    sys_wait,
--[SYS_pipe]    sys_pipe,
--[SYS_read]    sys_read,
--[SYS_kill]    sys_kill,
--[SYS_exec]    sys_exec,
--[SYS_fstat]   sys_fstat,
--[SYS_chdir]   sys_chdir,
--[SYS_dup]     sys_dup,
--[SYS_getpid]  sys_getpid,
--[SYS_sbrk]    sys_sbrk,
--[SYS_sleep]   sys_sleep,
--[SYS_uptime]  sys_uptime,
--[SYS_open]    sys_open,
--[SYS_write]   sys_write,
--[SYS_mknod]   sys_mknod,
--[SYS_unlink]  sys_unlink,
--[SYS_link]    sys_link,
--[SYS_mkdir]   sys_mkdir,
--[SYS_close]   sys_close,
-+    [SYS_fork] sys_fork,
-+    [SYS_exit] sys_exit,
-+    [SYS_wait] sys_wait,
-+    [SYS_pipe] sys_pipe,
-+    [SYS_read] sys_read,
-+    [SYS_kill] sys_kill,
-+    [SYS_exec] sys_exec,
-+    [SYS_fstat] sys_fstat,
-+    [SYS_chdir] sys_chdir,
-+    [SYS_dup] sys_dup,
-+    [SYS_getpid] sys_getpid,
-+    [SYS_sbrk] sys_sbrk,
-+    [SYS_sleep] sys_sleep,
-+    [SYS_uptime] sys_uptime,
-+    [SYS_open] sys_open,
-+    [SYS_write] sys_write,
-+    [SYS_mknod] sys_mknod,
-+    [SYS_unlink] sys_unlink,
-+    [SYS_link] sys_link,
-+    [SYS_mkdir] sys_mkdir,
-+    [SYS_close] sys_close,
- #ifdef LAB_NET
--[SYS_bind] sys_bind,
--[SYS_unbind] sys_unbind,
--[SYS_send] sys_send,
--[SYS_recv] sys_recv,
-+    [SYS_bind] sys_bind,
-+    [SYS_unbind] sys_unbind,
-+    [SYS_send] sys_send,
-+    [SYS_recv] sys_recv,
- #endif
- #ifdef LAB_PGTBL
--[SYS_pgpte] sys_pgpte,
--[SYS_kpgtbl] sys_kpgtbl,
-+    [SYS_pgpte] sys_pgpte,
-+    [SYS_kpgtbl] sys_kpgtbl,
- #endif
-+    [SYS_pgaccess] sys_pgaccess,
- };
- 
--
--
--void
--syscall(void)
-+void syscall(void)
- {
-   int num;
-   struct proc *p = myproc();
- 
-   num = p->trapframe->a7;
--  if(num > 0 && num < NELEM(syscalls) && syscalls[num]) {
-+  if (num > 0 && num < NELEM(syscalls) && syscalls[num])
-+  {
-     // Use num to lookup the system call function for num, call it,
-     // and store its return value in p->trapframe->a0
-     p->trapframe->a0 = syscalls[num]();
--  } else {
-+  }
-+  else
-+  {
-     printf("%d %s: unknown sys call %d\n",
--            p->pid, p->name, num);
-+           p->pid, p->name, num);
-     p->trapframe->a0 = -1;
-   }
- }
-diff --git a/kernel/syscall.h b/kernel/syscall.h
-index a122272..e435c6c 100644
---- a/kernel/syscall.h
-+++ b/kernel/syscall.h
-@@ -1,37 +1,39 @@
- // System call numbers
--#define SYS_fork    1
--#define SYS_exit    2
--#define SYS_wait    3
--#define SYS_pipe    4
--#define SYS_read    5
--#define SYS_kill    6
--#define SYS_exec    7
--#define SYS_fstat   8
--#define SYS_chdir   9
--#define SYS_dup    10
-+#define SYS_fork 1
-+#define SYS_exit 2
-+#define SYS_wait 3
-+#define SYS_pipe 4
-+#define SYS_read 5
-+#define SYS_kill 6
-+#define SYS_exec 7
-+#define SYS_fstat 8
-+#define SYS_chdir 9
-+#define SYS_dup 10
- #define SYS_getpid 11
--#define SYS_sbrk   12
--#define SYS_sleep  13
-+#define SYS_sbrk 12
-+#define SYS_sleep 13
- #define SYS_uptime 14
--#define SYS_open   15
--#define SYS_write  16
--#define SYS_mknod  17
-+#define SYS_open 15
-+#define SYS_write 16
-+#define SYS_mknod 17
- #define SYS_unlink 18
--#define SYS_link   19
--#define SYS_mkdir  20
--#define SYS_close  21
-+#define SYS_link 19
-+#define SYS_mkdir 20
-+#define SYS_close 21
- 
- // System calls for labs
--#define SYS_trace     22
--#define SYS_sysinfo   23
--#define SYS_sigalarm  24
-+#define SYS_trace 22
-+#define SYS_sysinfo 23
-+#define SYS_sigalarm 24
- #define SYS_sigreturn 25
--#define SYS_symlink   26
--#define SYS_mmap      27
--#define SYS_munmap    28
--#define SYS_bind      29
--#define SYS_unbind    30
--#define SYS_send      31
--#define SYS_recv      32
--#define SYS_pgpte     33
--#define SYS_kpgtbl    34
-+#define SYS_symlink 26
-+#define SYS_mmap 27
-+#define SYS_munmap 28
-+#define SYS_bind 29
-+#define SYS_unbind 30
-+#define SYS_send 31
-+#define SYS_recv 32
-+#define SYS_pgpte 33
-+#define SYS_kpgtbl 34
-+//
-+#define SYS_pgaccess 35
-diff --git a/kernel/sysproc.c b/kernel/sysproc.c
-index d9b7f9c..01c3703 100644
---- a/kernel/sysproc.c
-+++ b/kernel/sysproc.c
-@@ -12,7 +12,7 @@ sys_exit(void)
-   int n;
-   argint(0, &n);
-   exit(n);
--  return 0;  // not reached
-+  return 0; // not reached
- }
- 
- uint64
-@@ -43,7 +43,7 @@ sys_sbrk(void)
- 
-   argint(0, &n);
-   addr = myproc()->sz;
--  if(growproc(n) < 0)
-+  if (growproc(n) < 0)
-     return -1;
-   return addr;
- }
-@@ -54,14 +54,15 @@ sys_sleep(void)
-   int n;
-   uint ticks0;
- 
--
-   argint(0, &n);
--  if(n < 0)
-+  if (n < 0)
-     n = 0;
-   acquire(&tickslock);
-   ticks0 = ticks;
--  while(ticks - ticks0 < n){
--    if(killed(myproc())){
-+  while (ticks - ticks0 < n)
-+  {
-+    if (killed(myproc()))
-+    {
-       release(&tickslock);
-       return -1;
-     }
-@@ -71,29 +72,27 @@ sys_sleep(void)
-   return 0;
- }
- 
--
- #ifdef LAB_PGTBL
--int
--sys_pgpte(void)
-+int sys_pgpte(void)
- {
-   uint64 va;
--  struct proc *p;  
-+  struct proc *p;
- 
-   p = myproc();
-   argaddr(0, &va);
-   pte_t *pte = pgpte(p->pagetable, va);
--  if(pte != 0) {
--      return (uint64) *pte;
-+  if (pte != 0)
-+  {
-+    return (uint64)*pte;
-   }
-   return 0;
- }
- #endif
- 
- #ifdef LAB_PGTBL
--int
--sys_kpgtbl(void)
-+int sys_kpgtbl(void)
- {
--  struct proc *p;  
-+  struct proc *p;
- 
-   p = myproc();
-   vmprint(p->pagetable);
-@@ -101,7 +100,6 @@ sys_kpgtbl(void)
- }
- #endif
- 
--
- uint64
- sys_kill(void)
- {
-@@ -123,3 +121,29 @@ sys_uptime(void)
-   release(&tickslock);
-   return xticks;
- }
-+// Định nghĩa sys_pgaccess
-+int sys_pgaccess(void)
-+{
-+  // lab pgtbl: your code here.
-+  uint64 startaddr;
-+  int npage;
-+  uint64 useraddr;
-+  argaddr(0, &startaddr);
-+  argint(1, &npage);
-+  argaddr(2, &useraddr);
-+
-+  uint64 bitmask = 0;
-+  uint64 complement = ~PTE_A;
-+  struct proc *p = myproc();
-+  for (int i = 0; i < npage; ++i)
-+  {
-+    pte_t *pte = walk(p->pagetable, startaddr + i * PGSIZE, 0);
-+    if (*pte & PTE_A)
-+    {
-+      bitmask |= (1 << i);
-+      *pte &= complement;
-+    }
-+  }
-+  copyout(p->pagetable, useraddr, (char *)&bitmask, sizeof(bitmask));
-+  return 0;
-+}
-\ No newline at end of file
-diff --git a/kernel/vm.c b/kernel/vm.c
-index 7f388fe..c5b48aa 100644
---- a/kernel/vm.c
-+++ b/kernel/vm.c
-@@ -13,7 +13,7 @@
-  */
- pagetable_t kernel_pagetable;
- 
--extern char etext[];  // kernel.ld sets this to end of kernel code.
-+extern char etext[]; // kernel.ld sets this to end of kernel code.
- 
- extern char trampoline[]; // trampoline.S
- 
-@@ -23,7 +23,7 @@ kvmmake(void)
- {
-   pagetable_t kpgtbl;
- 
--  kpgtbl = (pagetable_t) kalloc();
-+  kpgtbl = (pagetable_t)kalloc();
-   memset(kpgtbl, 0, PGSIZE);
- 
-   // uart registers
-@@ -38,16 +38,16 @@ kvmmake(void)
- 
-   // pci.c maps the e1000's registers here.
-   kvmmap(kpgtbl, 0x40000000L, 0x40000000L, 0x20000, PTE_R | PTE_W);
--#endif  
-+#endif
- 
-   // PLIC
-   kvmmap(kpgtbl, PLIC, PLIC, 0x4000000, PTE_R | PTE_W);
- 
-   // map kernel text executable and read-only.
--  kvmmap(kpgtbl, KERNBASE, KERNBASE, (uint64)etext-KERNBASE, PTE_R | PTE_X);
-+  kvmmap(kpgtbl, KERNBASE, KERNBASE, (uint64)etext - KERNBASE, PTE_R | PTE_X);
- 
-   // map kernel data and the physical RAM we'll make use of.
--  kvmmap(kpgtbl, (uint64)etext, (uint64)etext, PHYSTOP-(uint64)etext, PTE_R | PTE_W);
-+  kvmmap(kpgtbl, (uint64)etext, (uint64)etext, PHYSTOP - (uint64)etext, PTE_R | PTE_W);
- 
-   // map the trampoline for trap entry/exit to
-   // the highest virtual address in the kernel.
-@@ -55,21 +55,19 @@ kvmmake(void)
- 
-   // allocate and map a kernel stack for each process.
-   proc_mapstacks(kpgtbl);
--  
-+
-   return kpgtbl;
- }
- 
- // Initialize the one kernel_pagetable
--void
--kvminit(void)
-+void kvminit(void)
- {
-   kernel_pagetable = kvmmake();
- }
- 
- // Switch h/w page table register to the kernel's page table,
- // and enable paging.
--void
--kvminithart()
-+void kvminithart()
- {
-   // wait for any previous writes to the page table memory to finish.
-   sfence_vma();
-@@ -95,20 +93,25 @@ kvminithart()
- pte_t *
- walk(pagetable_t pagetable, uint64 va, int alloc)
- {
--  if(va >= MAXVA)
-+  if (va >= MAXVA)
-     panic("walk");
- 
--  for(int level = 2; level > 0; level--) {
-+  for (int level = 2; level > 0; level--)
-+  {
-     pte_t *pte = &pagetable[PX(level, va)];
--    if(*pte & PTE_V) {
-+    if (*pte & PTE_V)
-+    {
-       pagetable = (pagetable_t)PTE2PA(*pte);
- #ifdef LAB_PGTBL
--      if(PTE_LEAF(*pte)) {
-+      if (PTE_LEAF(*pte))
-+      {
-         return pte;
-       }
- #endif
--    } else {
--      if(!alloc || (pagetable = (pde_t*)kalloc()) == 0)
-+    }
-+    else
-+    {
-+      if (!alloc || (pagetable = (pde_t *)kalloc()) == 0)
-         return 0;
-       memset(pagetable, 0, PGSIZE);
-       *pte = PA2PTE(pagetable) | PTE_V;
-@@ -126,28 +129,26 @@ walkaddr(pagetable_t pagetable, uint64 va)
-   pte_t *pte;
-   uint64 pa;
- 
--  if(va >= MAXVA)
-+  if (va >= MAXVA)
-     return 0;
- 
-   pte = walk(pagetable, va, 0);
--  if(pte == 0)
-+  if (pte == 0)
-     return 0;
--  if((*pte & PTE_V) == 0)
-+  if ((*pte & PTE_V) == 0)
-     return 0;
--  if((*pte & PTE_U) == 0)
-+  if ((*pte & PTE_U) == 0)
-     return 0;
-   pa = PTE2PA(*pte);
-   return pa;
- }
- 
--
- // add a mapping to the kernel page table.
- // only used when booting.
- // does not flush TLB or enable paging.
--void
--kvmmap(pagetable_t kpgtbl, uint64 va, uint64 pa, uint64 sz, int perm)
-+void kvmmap(pagetable_t kpgtbl, uint64 va, uint64 pa, uint64 sz, int perm)
- {
--  if(mappages(kpgtbl, va, sz, pa, perm) != 0)
-+  if (mappages(kpgtbl, va, sz, pa, perm) != 0)
-     panic("kvmmap");
- }
- 
-@@ -156,30 +157,30 @@ kvmmap(pagetable_t kpgtbl, uint64 va, uint64 pa, uint64 sz, int perm)
- // va and size MUST be page-aligned.
- // Returns 0 on success, -1 if walk() couldn't
- // allocate a needed page-table page.
--int
--mappages(pagetable_t pagetable, uint64 va, uint64 size, uint64 pa, int perm)
-+int mappages(pagetable_t pagetable, uint64 va, uint64 size, uint64 pa, int perm)
- {
-   uint64 a, last;
-   pte_t *pte;
- 
--  if((va % PGSIZE) != 0)
-+  if ((va % PGSIZE) != 0)
-     panic("mappages: va not aligned");
- 
--  if((size % PGSIZE) != 0)
-+  if ((size % PGSIZE) != 0)
-     panic("mappages: size not aligned");
- 
--  if(size == 0)
-+  if (size == 0)
-     panic("mappages: size");
--  
-+
-   a = va;
-   last = va + size - PGSIZE;
--  for(;;){
--    if((pte = walk(pagetable, a, 1)) == 0)
-+  for (;;)
-+  {
-+    if ((pte = walk(pagetable, a, 1)) == 0)
-       return -1;
--    if(*pte & PTE_V)
-+    if (*pte & PTE_V)
-       panic("mappages: remap");
-     *pte = PA2PTE(pa) | perm | PTE_V;
--    if(a == last)
-+    if (a == last)
-       break;
-     a += PGSIZE;
-     pa += PGSIZE;
-@@ -190,29 +191,31 @@ mappages(pagetable_t pagetable, uint64 va, uint64 size, uint64 pa, int perm)
- // Remove npages of mappings starting from va. va must be
- // page-aligned. The mappings must exist.
- // Optionally free the physical memory.
--void
--uvmunmap(pagetable_t pagetable, uint64 va, uint64 npages, int do_free)
-+void uvmunmap(pagetable_t pagetable, uint64 va, uint64 npages, int do_free)
- {
-   uint64 a;
-   pte_t *pte;
-   int sz;
- 
--  if((va % PGSIZE) != 0)
-+  if ((va % PGSIZE) != 0)
-     panic("uvmunmap: not aligned");
- 
--  for(a = va; a < va + npages*PGSIZE; a += sz){
-+  for (a = va; a < va + npages * PGSIZE; a += sz)
-+  {
-     sz = PGSIZE;
--    if((pte = walk(pagetable, a, 0)) == 0)
-+    if ((pte = walk(pagetable, a, 0)) == 0)
-       panic("uvmunmap: walk");
--    if((*pte & PTE_V) == 0) {
-+    if ((*pte & PTE_V) == 0)
-+    {
-       printf("va=%ld pte=%ld\n", a, *pte);
-       panic("uvmunmap: not mapped");
-     }
--    if(PTE_FLAGS(*pte) == PTE_V)
-+    if (PTE_FLAGS(*pte) == PTE_V)
-       panic("uvmunmap: not a leaf");
--    if(do_free){
-+    if (do_free)
-+    {
-       uint64 pa = PTE2PA(*pte);
--      kfree((void*)pa);
-+      kfree((void *)pa);
-     }
-     *pte = 0;
-   }
-@@ -224,8 +227,8 @@ pagetable_t
- uvmcreate()
- {
-   pagetable_t pagetable;
--  pagetable = (pagetable_t) kalloc();
--  if(pagetable == 0)
-+  pagetable = (pagetable_t)kalloc();
-+  if (pagetable == 0)
-     return 0;
-   memset(pagetable, 0, PGSIZE);
-   return pagetable;
-@@ -234,20 +237,18 @@ uvmcreate()
- // Load the user initcode into address 0 of pagetable,
- // for the very first process.
- // sz must be less than a page.
--void
--uvmfirst(pagetable_t pagetable, uchar *src, uint sz)
-+void uvmfirst(pagetable_t pagetable, uchar *src, uint sz)
- {
-   char *mem;
- 
--  if(sz >= PGSIZE)
-+  if (sz >= PGSIZE)
-     panic("uvmfirst: more than a page");
-   mem = kalloc();
-   memset(mem, 0, PGSIZE);
--  mappages(pagetable, 0, PGSIZE, (uint64)mem, PTE_W|PTE_R|PTE_X|PTE_U);
-+  mappages(pagetable, 0, PGSIZE, (uint64)mem, PTE_W | PTE_R | PTE_X | PTE_U);
-   memmove(mem, src, sz);
- }
- 
--
- // Allocate PTEs and physical memory to grow process from oldsz to
- // newsz, which need not be page aligned.  Returns new size or 0 on error.
- uint64
-@@ -257,21 +258,24 @@ uvmalloc(pagetable_t pagetable, uint64 oldsz, uint64 newsz, int xperm)
-   uint64 a;
-   int sz;
- 
--  if(newsz < oldsz)
-+  if (newsz < oldsz)
-     return oldsz;
- 
-   oldsz = PGROUNDUP(oldsz);
--  for(a = oldsz; a < newsz; a += sz){
-+  for (a = oldsz; a < newsz; a += sz)
-+  {
-     sz = PGSIZE;
-     mem = kalloc();
--    if(mem == 0){
-+    if (mem == 0)
-+    {
-       uvmdealloc(pagetable, a, oldsz);
-       return 0;
-     }
- #ifndef LAB_SYSCALL
-     memset(mem, 0, sz);
- #endif
--    if(mappages(pagetable, a, sz, (uint64)mem, PTE_R|PTE_U|xperm) != 0){
-+    if (mappages(pagetable, a, sz, (uint64)mem, PTE_R | PTE_U | xperm) != 0)
-+    {
-       kfree(mem);
-       uvmdealloc(pagetable, a, oldsz);
-       return 0;
-@@ -287,10 +291,11 @@ uvmalloc(pagetable_t pagetable, uint64 oldsz, uint64 newsz, int xperm)
- uint64
- uvmdealloc(pagetable_t pagetable, uint64 oldsz, uint64 newsz)
- {
--  if(newsz >= oldsz)
-+  if (newsz >= oldsz)
-     return oldsz;
- 
--  if(PGROUNDUP(newsz) < PGROUNDUP(oldsz)){
-+  if (PGROUNDUP(newsz) < PGROUNDUP(oldsz))
-+  {
-     int npages = (PGROUNDUP(oldsz) - PGROUNDUP(newsz)) / PGSIZE;
-     uvmunmap(pagetable, PGROUNDUP(newsz), npages, 1);
-   }
-@@ -300,31 +305,33 @@ uvmdealloc(pagetable_t pagetable, uint64 oldsz, uint64 newsz)
- 
- // Recursively free page-table pages.
- // All leaf mappings must already have been removed.
--void
--freewalk(pagetable_t pagetable)
-+void freewalk(pagetable_t pagetable)
- {
-   // there are 2^9 = 512 PTEs in a page table.
--  for(int i = 0; i < 512; i++){
-+  for (int i = 0; i < 512; i++)
-+  {
-     pte_t pte = pagetable[i];
--    if((pte & PTE_V) && (pte & (PTE_R|PTE_W|PTE_X)) == 0){
-+    if ((pte & PTE_V) && (pte & (PTE_R | PTE_W | PTE_X)) == 0)
-+    {
-       // this PTE points to a lower-level page table.
-       uint64 child = PTE2PA(pte);
-       freewalk((pagetable_t)child);
-       pagetable[i] = 0;
--    } else if(pte & PTE_V){
-+    }
-+    else if (pte & PTE_V)
-+    {
-       panic("freewalk: leaf");
-     }
-   }
--  kfree((void*)pagetable);
-+  kfree((void *)pagetable);
- }
- 
- // Free user memory pages,
- // then free page-table pages.
--void
--uvmfree(pagetable_t pagetable, uint64 sz)
-+void uvmfree(pagetable_t pagetable, uint64 sz)
- {
--  if(sz > 0)
--    uvmunmap(pagetable, 0, PGROUNDUP(sz)/PGSIZE, 1);
-+  if (sz > 0)
-+    uvmunmap(pagetable, 0, PGROUNDUP(sz) / PGSIZE, 1);
-   freewalk(pagetable);
- }
- 
-@@ -334,8 +341,7 @@ uvmfree(pagetable_t pagetable, uint64 sz)
- // physical memory.
- // returns 0 on success, -1 on failure.
- // frees any allocated pages on failure.
--int
--uvmcopy(pagetable_t old, pagetable_t new, uint64 sz)
-+int uvmcopy(pagetable_t old, pagetable_t new, uint64 sz)
- {
-   pte_t *pte;
-   uint64 pa, i;
-@@ -343,39 +349,40 @@ uvmcopy(pagetable_t old, pagetable_t new, uint64 sz)
-   char *mem;
-   int szinc;
- 
--  for(i = 0; i < sz; i += szinc){
-+  for (i = 0; i < sz; i += szinc)
-+  {
-     szinc = PGSIZE;
-     szinc = PGSIZE;
--    if((pte = walk(old, i, 0)) == 0)
-+    if ((pte = walk(old, i, 0)) == 0)
-       panic("uvmcopy: pte should exist");
--    if((*pte & PTE_V) == 0)
-+    if ((*pte & PTE_V) == 0)
-       panic("uvmcopy: page not present");
-     pa = PTE2PA(*pte);
-     flags = PTE_FLAGS(*pte);
--    if((mem = kalloc()) == 0)
-+    if ((mem = kalloc()) == 0)
-       goto err;
--    memmove(mem, (char*)pa, PGSIZE);
--    if(mappages(new, i, PGSIZE, (uint64)mem, flags) != 0){
-+    memmove(mem, (char *)pa, PGSIZE);
-+    if (mappages(new, i, PGSIZE, (uint64)mem, flags) != 0)
-+    {
-       kfree(mem);
-       goto err;
-     }
-   }
-   return 0;
- 
-- err:
-+err:
-   uvmunmap(new, 0, i / PGSIZE, 1);
-   return -1;
- }
- 
- // mark a PTE invalid for user access.
- // used by exec for the user stack guard page.
--void
--uvmclear(pagetable_t pagetable, uint64 va)
-+void uvmclear(pagetable_t pagetable, uint64 va)
- {
-   pte_t *pte;
--  
-+
-   pte = walk(pagetable, va, 0);
--  if(pte == 0)
-+  if (pte == 0)
-     panic("uvmclear");
-   *pte &= ~PTE_U;
- }
-@@ -383,31 +390,31 @@ uvmclear(pagetable_t pagetable, uint64 va)
- // Copy from kernel to user.
- // Copy len bytes from src to virtual address dstva in a given page table.
- // Return 0 on success, -1 on error.
--int
--copyout(pagetable_t pagetable, uint64 dstva, char *src, uint64 len)
-+int copyout(pagetable_t pagetable, uint64 dstva, char *src, uint64 len)
- {
-   uint64 n, va0, pa0;
-   pte_t *pte;
- 
--  while(len > 0){
-+  while (len > 0)
-+  {
-     va0 = PGROUNDDOWN(dstva);
-     if (va0 >= MAXVA)
-       return -1;
--    if((pte = walk(pagetable, va0, 0)) == 0) {
-+    if ((pte = walk(pagetable, va0, 0)) == 0)
-+    {
-       // printf("copyout: pte should exist 0x%x %d\n", dstva, len);
-       return -1;
-     }
- 
--
-     // forbid copyout over read-only user text pages.
--    if((*pte & PTE_W) == 0)
-+    if ((*pte & PTE_W) == 0)
-       return -1;
--    
-+
-     pa0 = walkaddr(pagetable, va0);
--    if(pa0 == 0)
-+    if (pa0 == 0)
-       return -1;
-     n = PGSIZE - (dstva - va0);
--    if(n > len)
-+    if (n > len)
-       n = len;
-     memmove((void *)(pa0 + (dstva - va0)), src, n);
- 
-@@ -421,18 +428,18 @@ copyout(pagetable_t pagetable, uint64 dstva, char *src, uint64 len)
- // Copy from user to kernel.
- // Copy len bytes to dst from virtual address srcva in a given page table.
- // Return 0 on success, -1 on error.
--int
--copyin(pagetable_t pagetable, char *dst, uint64 srcva, uint64 len)
-+int copyin(pagetable_t pagetable, char *dst, uint64 srcva, uint64 len)
- {
-   uint64 n, va0, pa0;
--  
--  while(len > 0){
-+
-+  while (len > 0)
-+  {
-     va0 = PGROUNDDOWN(srcva);
-     pa0 = walkaddr(pagetable, va0);
--    if(pa0 == 0)
-+    if (pa0 == 0)
-       return -1;
-     n = PGSIZE - (srcva - va0);
--    if(n > len)
-+    if (n > len)
-       n = len;
-     memmove(dst, (void *)(pa0 + (srcva - va0)), n);
- 
-@@ -447,28 +454,32 @@ copyin(pagetable_t pagetable, char *dst, uint64 srcva, uint64 len)
- // Copy bytes to dst from virtual address srcva in a given page table,
- // until a '\0', or max.
- // Return 0 on success, -1 on error.
--int
--copyinstr(pagetable_t pagetable, char *dst, uint64 srcva, uint64 max)
-+int copyinstr(pagetable_t pagetable, char *dst, uint64 srcva, uint64 max)
- {
-   uint64 n, va0, pa0;
-   int got_null = 0;
- 
--  while(got_null == 0 && max > 0){
-+  while (got_null == 0 && max > 0)
-+  {
-     va0 = PGROUNDDOWN(srcva);
-     pa0 = walkaddr(pagetable, va0);
--    if(pa0 == 0)
-+    if (pa0 == 0)
-       return -1;
-     n = PGSIZE - (srcva - va0);
--    if(n > max)
-+    if (n > max)
-       n = max;
- 
--    char *p = (char *) (pa0 + (srcva - va0));
--    while(n > 0){
--      if(*p == '\0'){
-+    char *p = (char *)(pa0 + (srcva - va0));
-+    while (n > 0)
-+    {
-+      if (*p == '\0')
-+      {
-         *dst = '\0';
-         got_null = 1;
-         break;
--      } else {
-+      }
-+      else
-+      {
-         *dst = *p;
-       }
-       --n;
-@@ -479,26 +490,50 @@ copyinstr(pagetable_t pagetable, char *dst, uint64 srcva, uint64 max)
- 
-     srcva = va0 + PGSIZE;
-   }
--  if(got_null){
-+  if (got_null)
-+  {
-     return 0;
--  } else {
-+  }
-+  else
-+  {
-     return -1;
-   }
- }
- 
--
- #ifdef LAB_PGTBL
--void
--vmprint(pagetable_t pagetable) {
--  // your code here
-+static void
-+vmprint_rec(pagetable_t pagetable, int level)
-+{
-+  for (int i = 0; i < 512; i++)
-+  {
-+    pte_t pte = pagetable[i];
-+    if (pte & PTE_V)
-+    {
-+      for (int j = 0; j < level; j++)
-+        printf(" ..");
-+      printf("%d: pte %p pa %p\n", i, (void *)pte, (void *)PTE2PA(pte));
-+
-+      if ((pte & (PTE_R | PTE_W | PTE_X)) == 0)
-+      {
-+        pagetable_t child = (pagetable_t)PTE2PA(pte);
-+        vmprint_rec(child, level + 1);
-+      }
-+    }
-+  }
- }
--#endif
- 
-+void vmprint(pagetable_t pagetable)
-+{
-+  printf("page table %p\n", pagetable);
-+  vmprint_rec(pagetable, 1);
-+}
- 
-+#endif
- 
- #ifdef LAB_PGTBL
--pte_t*
--pgpte(pagetable_t pagetable, uint64 va) {
-+pte_t *
-+pgpte(pagetable_t pagetable, uint64 va)
-+{
-   return walk(pagetable, va, 0);
- }
- #endif
-diff --git a/user/pgtbltest.c b/user/pgtbltest.c
-index cde6e03..f6bc583 100644
---- a/user/pgtbltest.c
-+++ b/user/pgtbltest.c
-@@ -1,142 +1,79 @@
- #include "kernel/param.h"
--#include "kernel/fcntl.h"
- #include "kernel/types.h"
- #include "kernel/riscv.h"
- #include "user/user.h"
- 
--#define N (8 * (1 << 20))
-+#define PAGES 16
- 
- void print_pgtbl();
--void print_kpgtbl();
--void ugetpid_test();
--void superpg_test();
-+void pgaccess_test();
- 
--int
--main(int argc, char *argv[])
-+int main(int argc, char *argv[])
- {
-   print_pgtbl();
--  ugetpid_test();
--  print_kpgtbl();
--  superpg_test();
--  printf("pgtbltest: all tests succeeded\n");
-+  pgaccess_test();
-+  printf("pgtbltest: OK\n");
-   exit(0);
- }
- 
--char *testname = "???";
-+/* -------------------------------------------------- */
- 
--void
--err(char *why)
-+void print_pte(uint64 va)
- {
--  printf("pgtbltest: %s failed: %s, pid=%d\n", testname, why, getpid());
--  exit(1);
-+  pte_t pte = (pte_t)pgpte((void *)va);
-+  printf("va 0x%lx pte 0x%lx pa 0x%lx perm 0x%lx\n",
-+         va, pte, PTE2PA(pte), PTE_FLAGS(pte));
- }
- 
--void
--print_pte(uint64 va)
--{
--    pte_t pte = (pte_t) pgpte((void *) va);
--    printf("va 0x%lx pte 0x%lx pa 0x%lx perm 0x%lx\n", va, pte, PTE2PA(pte), PTE_FLAGS(pte));
--}
--
--void
--print_pgtbl()
-+void print_pgtbl()
- {
-   printf("print_pgtbl starting\n");
--  for (uint64 i = 0; i < 10; i++) {
-+
-+  for (uint64 i = 0; i < 10; i++)
-     print_pte(i * PGSIZE);
--  }
--  uint64 top = MAXVA/PGSIZE;
--  for (uint64 i = top-10; i < top; i++) {
-+
-+  uint64 top = MAXVA / PGSIZE;
-+  for (uint64 i = top - 10; i < top; i++)
-     print_pte(i * PGSIZE);
--  }
-+
-   printf("print_pgtbl: OK\n");
- }
- 
--void
--ugetpid_test()
--{
--  int i;
--
--  printf("ugetpid_test starting\n");
--  testname = "ugetpid_test";
--
--  for (i = 0; i < 64; i++) {
--    int ret = fork();
--    if (ret != 0) {
--      wait(&ret);
--      if (ret != 0)
--        exit(1);
--      continue;
--    }
--    if (getpid() != ugetpid())
--      err("missmatched PID");
--    exit(0);
--  }
--  printf("ugetpid_test: OK\n");
--}
-+/* -------------------------------------------------- */
- 
--void
--print_kpgtbl()
-+void pgaccess_test()
- {
--  printf("print_kpgtbl starting\n");
--  kpgtbl();
--  printf("print_kpgtbl: OK\n");
--}
--
-+  printf("pgaccess_test starting\n");
- 
--void
--supercheck(uint64 s)
--{
--  pte_t last_pte = 0;
--
--  for (uint64 p = s;  p < s + 512 * PGSIZE; p += PGSIZE) {
--    pte_t pte = (pte_t) pgpte((void *) p);
--    if(pte == 0)
--      err("no pte");
--    if ((uint64) last_pte != 0 && pte != last_pte) {
--        err("pte different");
--    }
--    if((pte & PTE_V) == 0 || (pte & PTE_R) == 0 || (pte & PTE_W) == 0){
--      err("pte wrong");
--    }
--    last_pte = pte;
-+  char *buf = sbrk(PAGES * PGSIZE);
-+  if (buf == (char *)-1)
-+  {
-+    printf("sbrk failed\n");
-+    exit(1);
-   }
- 
--  for(int i = 0; i < 512; i += PGSIZE){
--    *(int*)(s+i) = i;
--  }
-+  // touch some pages
-+  buf[0] = 1;
-+  buf[2 * PGSIZE] = 1;
-+  buf[5 * PGSIZE] = 1;
- 
--  for(int i = 0; i < 512; i += PGSIZE){
--    if(*(int*)(s+i) != i)
--      err("wrong value");
-+  uint64 mask = 0;
-+  if (pgaccess(buf, PAGES, &mask) < 0)
-+  {
-+    printf("pgaccess failed\n");
-+    exit(1);
-   }
--}
- 
--void
--superpg_test()
--{
--  int pid;
--  
--  printf("superpg_test starting\n");
--  testname = "superpg_test";
--  
--  char *end = sbrk(N);
--  if (end == 0 || end == (char*)0xffffffffffffffff)
--    err("sbrk failed");
--  
--  uint64 s = SUPERPGROUNDUP((uint64) end);
--  supercheck(s);
--  if((pid = fork()) < 0) {
--    err("fork");
--  } else if(pid == 0) {
--    supercheck(s);
--    exit(0);
--  } else {
--    int status;
--    wait(&status);
--    if (status != 0) {
--      exit(0);
--    }
-+  printf("pgaccess mask = 0x%lx\n", mask);
-+
-+  // expect bits 0,2,5 set
-+  if ((mask & (1L << 0)) == 0 ||
-+      (mask & (1L << 2)) == 0 ||
-+      (mask & (1L << 5)) == 0)
-+  {
-+    printf("pgaccess wrong mask\n");
-+    exit(1);
-   }
--  printf("superpg_test: OK\n");  
-+
-+  printf("pgaccess_test: OK\n");
- }
-diff --git a/user/user.h b/user/user.h
-index b91fd89..300e131 100644
---- a/user/user.h
-+++ b/user/user.h
-@@ -7,55 +7,57 @@ struct stat;
- // system calls
- int fork(void);
- int exit(int) __attribute__((noreturn));
--int wait(int*);
--int pipe(int*);
--int write(int, const void*, int);
--int read(int, void*, int);
-+int wait(int *);
-+int pipe(int *);
-+int write(int, const void *, int);
-+int read(int, void *, int);
- int close(int);
- int kill(int);
--int exec(const char*, char**);
--int open(const char*, int);
--int mknod(const char*, short, short);
--int unlink(const char*);
--int fstat(int fd, struct stat*);
--int link(const char*, const char*);
--int mkdir(const char*);
--int chdir(const char*);
-+int exec(const char *, char **);
-+int open(const char *, int);
-+int mknod(const char *, short, short);
-+int unlink(const char *);
-+int fstat(int fd, struct stat *);
-+int link(const char *, const char *);
-+int mkdir(const char *);
-+int chdir(const char *);
- int dup(int);
- int getpid(void);
--char* sbrk(int);
-+char *sbrk(int);
- int sleep(int);
- int uptime(void);
- #ifdef LAB_NET
- int bind(uint32);
- int unbind(uint32);
- int send(uint32, uint32, uint32, char *, uint32);
--int recv(uint32, uint32*, uint32*, char *, uint32);
-+int recv(uint32, uint32 *, uint32 *, char *, uint32);
- #endif
- #ifdef LAB_PGTBL
- int ugetpid(void);
--uint64 pgpte(void*);
-+uint64 pgpte(void *);
- void kpgtbl(void);
- #endif
- 
- // ulib.c
--int stat(const char*, struct stat*);
--char* strcpy(char*, const char*);
--void *memmove(void*, const void*, int);
--char* strchr(const char*, char c);
--int strcmp(const char*, const char*);
--void fprintf(int, const char*, ...) __attribute__ ((format (printf, 2, 3)));
--void printf(const char*, ...) __attribute__ ((format (printf, 1, 2)));
--char* gets(char*, int max);
--uint strlen(const char*);
--void* memset(void*, int, uint);
--int atoi(const char*);
-+int stat(const char *, struct stat *);
-+char *strcpy(char *, const char *);
-+void *memmove(void *, const void *, int);
-+char *strchr(const char *, char c);
-+int strcmp(const char *, const char *);
-+void fprintf(int, const char *, ...) __attribute__((format(printf, 2, 3)));
-+void printf(const char *, ...) __attribute__((format(printf, 1, 2)));
-+char *gets(char *, int max);
-+uint strlen(const char *);
-+void *memset(void *, int, uint);
-+int atoi(const char *);
- int memcmp(const void *, const void *, uint);
- void *memcpy(void *, const void *, uint);
- #ifdef LAB_LOCK
--int statistics(void*, int);
-+int statistics(void *, int);
- #endif
- 
- // umalloc.c
--void* malloc(uint);
--void free(void*);
-+void *malloc(uint);
-+void free(void *);
-+
-+int pgaccess(void *, int, uint64 *);
-diff --git a/user/usys.pl b/user/usys.pl
-index 2c19fa6..ba10d38 100755
---- a/user/usys.pl
-+++ b/user/usys.pl
-@@ -42,3 +42,5 @@ entry("send");
- entry("recv");
- entry("pgpte");
- entry("kpgtbl");
-+entry("pgaccess");
-+
diff --git a/kernel/sysproc.c b/kernel/sysproc.c
index 01c3703..0eee9ea 100644
--- a/kernel/sysproc.c
+++ b/kernel/sysproc.c
@@ -122,28 +122,30 @@ sys_uptime(void)
   return xticks;
 }
 // Định nghĩa sys_pgaccess
-int sys_pgaccess(void)
+uint64
+sys_pgaccess(void)
 {
-  // lab pgtbl: your code here.
-  uint64 startaddr;
-  int npage;
-  uint64 useraddr;
-  argaddr(0, &startaddr);
-  argint(1, &npage);
-  argaddr(2, &useraddr);
-
-  uint64 bitmask = 0;
-  uint64 complement = ~PTE_A;
+  uint64 va;
+  int pages;
+  uint64 abitsaddr;
+  argaddr(0, &va);
+  argint(1, &pages);
+  argaddr(2, &abitsaddr);
+
+  if(pages > 64) return -1;
+
+  unsigned int mask = 0;
   struct proc *p = myproc();
-  for (int i = 0; i < npage; ++i)
-  {
-    pte_t *pte = walk(p->pagetable, startaddr + i * PGSIZE, 0);
-    if (*pte & PTE_A)
-    {
-      bitmask |= (1 << i);
-      *pte &= complement;
+
+  for(int i = 0; i < pages; i++){
+    uint64 current_va = va + i * PGSIZE;
+    pte_t *pte = walk(p->pagetable, current_va, 0);
+    
+    if(pte != 0 && (*pte & PTE_V) && (*pte & PTE_A)){
+      mask |= (1 << i);      
+      *pte &= ~PTE_A; 
     }
   }
-  copyout(p->pagetable, useraddr, (char *)&bitmask, sizeof(bitmask));
-  return 0;
+
+  return copyout(p->pagetable, abitsaddr, (char *)&mask, sizeof(mask));
 }
\ No newline at end of file
